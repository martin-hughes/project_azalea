/// @file
/// @brief A generic, in-memory virtual terminal.

//#define ENABLE_TRACING

#include "gen_vt.h"

#include <string.h>

void callback(tmt_msg_t m, TMT *vt, const void *a, void *p);

/// @brief Construct a virtual terminal
///
/// @param keyboard_pipe The pipe to write key presses in to, which will come out as stdin in an attached process.
terms::vt::vt(std::shared_ptr<IWritable> keyboard_pipe) :
  terms::generic{keyboard_pipe, "term"}
{

}

terms::vt::vt(std::shared_ptr<IWritable> keyboard_pipe, std::string root_name) :
  terms::generic{keyboard_pipe, root_name}
{
  KL_TRC_ENTRY;

  inner_vt = tmt_open(25, 80, callback, this, NULL);

  KL_TRC_EXIT;
}

terms::vt::~vt()
{
  tmt_close(inner_vt);
  inner_vt = nullptr;
}

bool terms::vt::start()
{
  bool result{true};

  KL_TRC_ENTRY;

  set_device_status(DEV_STATUS::STARTING);

  tmt_reset(inner_vt);

  set_device_status(DEV_STATUS::OK);


  KL_TRC_TRACE(TRC_LVL::EXTRA, "Result: ", result, "\n");
  KL_TRC_EXIT;

  return result;
}

bool terms::vt::stop()
{
  bool result{true};

  KL_TRC_ENTRY;

  set_device_status(DEV_STATUS::STOPPED);

  KL_TRC_TRACE(TRC_LVL::EXTRA, "Result: ", result, "\n");
  KL_TRC_EXIT;

  return result;
}

bool terms::vt::reset()
{
  bool result{true};

  KL_TRC_ENTRY;

  set_device_status(DEV_STATUS::RESET);

  tmt_reset(inner_vt);

  // Reset terminal options to defaults.
  filters = terminal_opts();

  set_device_status(DEV_STATUS::STOPPED);

  KL_TRC_TRACE(TRC_LVL::EXTRA, "Result: ", result, "\n");
  KL_TRC_EXIT;

  return result;
}


/// @brief Called by libtmt whenever an interesting event occurs.
///
/// Forward this event to the terminal that should be handling it.
///
/// @param m The message sent to this terminal.
///
/// @param vt The terminal that raised the callback.
///
/// @param a The parameter associated with message m.
///
/// @param p The parameter passed to tmt_open - which will be the terminal object's this pointer.
void callback(tmt_msg_t m, TMT *vt, const void *a, void *p)
{
  terms::vt *term{reinterpret_cast<terms::vt *>(p)};
  DEV_STATUS s;

  KL_TRC_ENTRY;

  // There is an assumption here that libtmt will never generate a callback for a terminal that no longer exists, which
  // is reasonable because the VT is wrapped in C++ class and isn't called directly.
  ASSERT(term != nullptr);
  s = term->get_device_status();

  // Don't forward messages if the device is failed, stopped or not fully created - it might still be mid-construction,
  // in which case tmt_callback may not point at the desired function!
  if ((s != DEV_STATUS::FAILED) &&
      (s != DEV_STATUS::UNKNOWN) &&
      (s != DEV_STATUS::STOPPED))
  {
    KL_TRC_TRACE(TRC_LVL::FLOW, "Forward message\n");
    term->tmt_callback(m, vt, a);
  }

  KL_TRC_EXIT;
}

/// @brief Handle a callback generated by libtmt for this terminal.
///
/// @param m The message sent to this terminal.
///
/// @param vt The terminal that raised the callback.
///
/// @param a The parameter associated with message m.
void terms::vt::tmt_callback(tmt_msg_t m, TMT *vt, const void *a)
{
  /* grab a pointer to the virtual screen */
  const TMTPOINT *c = tmt_cursor(vt);
  const char *response{reinterpret_cast<const char *>(a)};
  uint64_t response_len;
  uint64_t written;

  KL_TRC_ENTRY;

  switch (m)
  {
  case TMT_MSG_BELL:
    KL_TRC_TRACE(TRC_LVL::IMPORTANT, "BELL\n");
    break;

  case TMT_MSG_UPDATE:
    KL_TRC_TRACE(TRC_LVL::FLOW, "Screen changed\n");
    panic("Generic terminal update - don't know what to do.");
    break;

  case TMT_MSG_ANSWER:
    KL_TRC_TRACE(TRC_LVL::IMPORTANT, "Terminal response: ", response, "\n");
    response_len = strlen(response);
    stdin_writer->write_bytes(0, response_len, reinterpret_cast<const uint8_t *>(response), response_len, written);

    break;

  case TMT_MSG_MOVED:
    /* the cursor moved; a is a pointer to the cursor's TMTPOINT */
    KL_TRC_TRACE(TRC_LVL::FLOW, "Cursor moved to row ", c->r, ", col: ", c->c, "\n");
    this->set_cursor_pos(c->c, c->r);
    tmt_clean(vt);
    break;

  case TMT_MSG_CURSOR:
    char cmd{reinterpret_cast<const char *>(a)[0]};

    switch (cmd)
    {
    case 't':
      KL_TRC_TRACE(TRC_LVL::FLOW, "Request to display cursor\n");
      this->enable_cursor();
      break;

    case 'f':
      KL_TRC_TRACE(TRC_LVL::FLOW, "Request to hide cursor\n");
      this->disable_cursor();
      break;

    default:
      panic("Unknown cursor state from tmt");
    }

    break;
  }

  KL_TRC_EXIT;
}

void terms::vt::write_raw_string(const char *out_string, uint16_t num_chars)
{
  KL_TRC_ENTRY;

  if (get_device_status() == DEV_STATUS::OK)
  {
    KL_TRC_TRACE(TRC_LVL::FLOW, "Handle request while running\n");
    tmt_write(inner_vt, out_string, num_chars);
  }
  else
  {
    KL_TRC_TRACE(TRC_LVL::FLOW, "Ignore request while not running\n");
  }

  KL_TRC_EXIT;
}
