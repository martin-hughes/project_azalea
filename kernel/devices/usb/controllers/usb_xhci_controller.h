/// @file
/// @brief Define a generic xHCI controller.

#pragma once

#include "devices/usb/controllers/usb_gen_controller.h"
#include "devices/usb/controllers/usb_xhci_register_types.h"
#include "devices/usb/controllers/usb_xhci_trb_types.h"
#include "devices/usb/controllers/usb_xhci_trb_ring.h"
#include "devices/usb/controllers/usb_xhci_port.h"
#include "devices/usb/controllers/usb_xhci_capabilities.h"
#include "devices/usb/controllers/usb_xhci_contexts.h"
#include "processor/work_queue.h"
#include "klib/klib.h"
#include <memory>

namespace usb { namespace xhci
{
  class device_core;

  /// @brief A simple way to enable USB-devices to wait on the responses to their commands.
  ///
  class command_response : public work::work_response
  {
  public:
    command_completion_event_trb trb; ///< The command completion event TRB generated by an earlier command.
  };

  /// @brief Structure to help correlate commands to the device that generated them.
  ///
  struct xhci_command_data
  {
    uint64_t command_trb_phys_addr; ///< The physical address of the command TRB for the command.
    template_trb generated_trb;     ///< A copy of the command TRB that was enqueued.
    device_core *requesting_device; ///< The core for the device generating the request.
    std::shared_ptr<command_response> response_item; ///< Stores data about the controller's response to the command.
  };

  /// @brief An implementation of the USB xHCI specification
  ///
  class controller : public usb_gen_controller, protected work::worker_object
  {
    /// @cond
    // Doxygen doesn't seem to understand 'friend'
    friend trb_event_ring;
    /// @endcond

  public:
    controller(pci_address address);
    virtual ~controller();

    virtual bool handle_translated_interrupt_fast(uint8_t interrupt_offset,
                                                  uint8_t raw_interrupt_num) override;
    virtual void handle_translated_interrupt_slow(uint8_t interrupt_offset,
                                                  uint8_t raw_interrupt_num) override;

    bool start();
    bool stop(bool force = false);
    bool reset();

  protected:
    //-------------------
    // Member Variables/
    //-------------------

    // xHCI control structures.
    volatile caps_regs *capability_regs; ///< Pointer to the Capability Registers
    volatile oper_regs *operational_regs; ///< Pointer to the Operational Registers.
    std::unique_ptr<device_context *[]> device_ctxt_base_addr_array; ///< Pointer to the DCBAAP.
    std::unique_ptr<device_core *[]> slot_to_device_obj_map; ///< Maps slots to device objects, for easy reference.
    trb_command_ring command_ring; ///< The controller's one-and-only command ring.
    uint64_t runtime_regs_virt_addr; ///< Virtual address of the Runtime Registers.
    volatile uint32_t *doorbell_regs; ///< Beginning of the doorbell registers.
    interrupter_regs *interrupters; ///< Pointer to the interrupter table (part of the runtime registers)
    port_regs *port_control_regs; ///< Port control registers (part of the runtime registers)
    extended_cap_hdr *extended_caps; ///< Pointer to extended capabilities, used for determining port speeds.

    // I'm going to manage the memory for this one manually instead of via the magic pointer classes, since the
    // individual objects can't be managed via new/delete. This is a list of the physical pages we've allocated to
    // store scratchpad buffers.
    uint64_t *scratchpad_virt_array_ptr; ///< Pointer to the possibly required scratchpad buffer pointer array.
    uint64_t *scratchpad_phys_page_ptr_array; ///< Physical address of the scratchpad buffer pointer array.
    uint16_t num_scratchpad_page_ptrs; ///< Number of allocated scratchpad buffers.

    // For now, only include one event ring.
    std::unique_ptr<trb_event_ring> event_ring; ///< The only allocated event ring.

    std::unique_ptr<root_port[]> root_ports; ///< Port objects for all root ports attached to this controller.

    //-------------------
    // Member functions.
    //-------------------

    // Initialization helpers.
    void initialize_registers(pci_address address);
    bool initial_hardware_check();
    bool prepare_control_structures();
    uint64_t generate_scratchpad_array(uint16_t num_scratchpads);
    bool examine_extended_caps();
    bool examine_proto_support_cap(supported_protocols_cap *cap);

    // Event handlers.
    void dispatch_event_trb(template_trb &trb);
    void handle_port_status_change_event(port_status_change_event_trb &trb);
    void handle_command_completion(command_completion_event_trb &trb);
    void handle_transfer_event(transfer_event_trb &trb);

    void handle_enable_slot_completion(command_completion_event_trb &trb, device_core *requesting_dev);
    void handle_address_device_completion(command_completion_event_trb &trb, device_core *requesting_dev);

    // Asynchronous request interface
    void handle_work_item(std::shared_ptr<work::work_item> item) override;

    // Driver-generated command requests.
  public:
    bool generic_device_command(template_trb *trb, device_core *req_dev);
    // The first two require special handling.
    void request_slot(device_core *req_dev);
    void address_device(device_core *req_dev, uint64_t input_ctxt_phys_addr, uint8_t slot_id);
    // The remainder are pretty generic.
    bool evaluate_context(device_core *req_dev, uint64_t input_ctxt_phys_addr, uint8_t slot_id);
    bool configure_endpoints(device_core *req_dev, uint64_t input_ctxt_phys_addr, uint8_t slot_id);

    void ring_doorbell(uint8_t doorbell_num, uint8_t endpoint_code, uint16_t stream_id = 0);
  };
}};