/// @file
/// @brief Define a generic xHCI controller.

#pragma once

#include <memory>

#include "usb_gen_controller.h"
#include "usb_xhci_register_types.h"
#include "usb_xhci_trb_types.h"
#include "usb_xhci_trb_ring.h"
#include "usb_xhci_port.h"
#include "usb_xhci_capabilities.h"
#include "usb_xhci_contexts.h"
#include "work_queue.h"

namespace usb { namespace xhci
{
  class device_core;

  /// @brief A simple way to enable USB-devices to wait on the responses to their commands.
  ///
  class command_response
  {
  public:
    command_completion_event_trb trb; ///< The command completion event TRB generated by an earlier command.
  };

  /// @brief Structure to help correlate commands to the device that generated them.
  ///
  struct xhci_command_data
  {
    uint64_t command_trb_phys_addr; ///< The physical address of the command TRB for the command.
    template_trb generated_trb;     ///< A copy of the command TRB that was enqueued.
    std::shared_ptr<device_core> requesting_device; ///< The core for the device generating the request.
    std::shared_ptr<command_response> response_item; ///< Stores data about the controller's response to the command.
  };

  /// @brief Message sent when a command issued by an XHCI controller completes.
  class command_complete_msg : public msg::root_msg
  {
  public:
    command_complete_msg(uint8_t cmd, uint8_t code);

    uint8_t generated_command; ///< The value of TRB type for the generated command.
    uint8_t completion_code; ///< The TRB completion code of the completed command.
  };

  /// @brief An implementation of the USB xHCI specification
  ///
  class controller : public usb_gen_controller
  {
    /// @cond
    // Doxygen doesn't seem to understand 'friend'
    friend trb_event_ring;
    /// @endcond

  public:
    controller(pci_address address);
    virtual ~controller();

    // Overrides of IDevice
    virtual bool start() override;
    virtual bool stop() override;
    virtual bool reset() override;

    // Overrides of IInterruptReceiver
    virtual bool handle_translated_interrupt_fast(uint8_t interrupt_offset,
                                                  uint8_t raw_interrupt_num) override;
    virtual void handle_translated_interrupt_slow(uint8_t interrupt_offset,
                                                  uint8_t raw_interrupt_num) override;

    // Local functions.
    bool controller_start();
    bool controller_stop();
    bool controller_reset();

  protected:
    //-------------------
    // Member Variables/
    //-------------------

    // xHCI control structures.
    volatile caps_regs *capability_regs; ///< Pointer to the Capability Registers
    volatile oper_regs *operational_regs; ///< Pointer to the Operational Registers.
    std::unique_ptr<device_context *[]> device_ctxt_base_addr_array; ///< Pointer to the DCBAAP.
    std::unique_ptr<std::shared_ptr<device_core>[]> slot_to_device_obj_map; ///< Maps slots to device objects, for easy reference.
    trb_command_ring command_ring; ///< The controller's one-and-only command ring.
    uint64_t runtime_regs_virt_addr; ///< Virtual address of the Runtime Registers.
    volatile uint32_t *doorbell_regs; ///< Beginning of the doorbell registers.
    interrupter_regs *interrupters; ///< Pointer to the interrupter table (part of the runtime registers)
    port_regs *port_control_regs; ///< Port control registers (part of the runtime registers)
    extended_cap_hdr *extended_caps; ///< Pointer to extended capabilities, used for determining port speeds.

    // I'm going to manage the memory for this one manually instead of via the magic pointer classes, since the
    // individual objects can't be managed via new/delete. This is a list of the physical pages we've allocated to
    // store scratchpad buffers.
    uint64_t *scratchpad_virt_array_ptr; ///< Pointer to the possibly required scratchpad buffer pointer array.
    uint64_t *scratchpad_phys_page_ptr_array; ///< Physical address of the scratchpad buffer pointer array.
    uint16_t num_scratchpad_page_ptrs; ///< Number of allocated scratchpad buffers.

    // For now, only include one event ring.
    std::unique_ptr<trb_event_ring> event_ring; ///< The only allocated event ring.

    std::unique_ptr<root_port[]> root_ports; ///< Port objects for all root ports attached to this controller.

    /// @brief Has this device permanently failed?
    ///
    /// Examples of such errors would be a fault found during initial setup or an inability to create the relevant
    /// control structures.
    bool permanently_failed{false};

    //-------------------
    // Member functions.
    //-------------------

    // Initialization helpers.
    void initialize_registers(pci_address address);
    bool initial_hardware_check();
    bool prepare_control_structures();
    uint64_t generate_scratchpad_array(uint16_t num_scratchpads);
    bool examine_extended_caps();
    bool examine_proto_support_cap(supported_protocols_cap *cap);

    // Event handlers.
    void dispatch_event_trb(template_trb &trb);
    void handle_port_status_change_event(port_status_change_event_trb &trb);
    void handle_command_completion(command_completion_event_trb &trb);
    void handle_transfer_event(transfer_event_trb &trb);

    void handle_enable_slot_completion(command_completion_event_trb &trb, std::shared_ptr<device_core> requesting_dev);
    void handle_address_device_completion(command_completion_event_trb &trb,
                                          std::shared_ptr<device_core> requesting_dev);

    // Driver-generated command requests.
  public:
    bool generic_device_command(template_trb *trb, std::shared_ptr<device_core> req_dev);
    // The first two require special handling.
    void request_slot(std::shared_ptr<device_core> req_dev);
    void address_device(std::shared_ptr<device_core> req_dev, uint64_t input_ctxt_phys_addr, uint8_t slot_id);
    // The remainder are pretty generic.
    bool evaluate_context(std::shared_ptr<device_core> req_dev, uint64_t input_ctxt_phys_addr, uint8_t slot_id);
    bool configure_endpoints(std::shared_ptr<device_core> req_dev, uint64_t input_ctxt_phys_addr, uint8_t slot_id);

    void ring_doorbell(uint8_t doorbell_num, uint8_t endpoint_code, uint16_t stream_id = 0);
  };
}};