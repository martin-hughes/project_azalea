/// @file
/// @brief Exception handlers for the kernel.
///
/// Page faults are handled in interrupts-x64.cpp

#define ENABLE_TRACING

#include "processor.h"
#include "processor-x64-int.h"
#include "proc_interrupt_handlers-x64.h"

namespace
{
  /// @brief Handler for most fault conditions
  ///
  /// @param k_rsp Value of RSP register after kernel save stack process complete and passed to exception or fault
  ///              handler.
  ///
  /// @param r_rip Value of RIP in interrupted process.
  ///
  /// @param r_rsp Value of RSP in interrupted process.
  void default_handler(uint64_t k_rsp, uint64_t r_rip, uint64_t r_rsp, const char *error_string)
  {
    KL_TRC_ENTRY;

    task_thread *cur_thread = task_get_cur_thread();
    std::shared_ptr<task_process> parent;
    if (cur_thread)
    {
      KL_TRC_TRACE(TRC_LVL::FLOW, "Save parent process\n");
      parent = cur_thread->parent_process;
    }

    if (!cur_thread || parent->kernel_mode || (r_rip > 0x8000000000000000ULL))
    {
      KL_TRC_TRACE(TRC_LVL::FLOW, "Kernel space process fault: ", error_string, "\n");
      KL_TRC_TRACE(TRC_LVL::FLOW, "RIP: ", r_rip, ", RSP: ", r_rsp, "\n");

      panic(error_string, true, k_rsp, r_rip, r_rsp);
    }
    else if (parent)
    {
      KL_TRC_TRACE(TRC_LVL::FLOW, "User-mode process fault in ", parent.get(), ". Cause: ", error_string, "\n");
      parent->stop_process();
      parent->proc_status = OPER_STATUS::FAILED;
      parent->exit_code = r_rip;
      parent->add_to_dead_list();
      task_yield();
      panic("Failed to abort faulty process");
    }
    else
    {
      KL_TRC_TRACE(TRC_LVL::FLOW, "Unidentified process failure\n");
      panic("Failure in unknown process", true, k_rsp, r_rip, r_rsp);
    }

    KL_TRC_EXIT;
  }
}

/// @brief Divide by zero fault handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param opt Optional parameter generated by ASM layer (currently always zero)
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_div_by_zero_fault_handler(uint64_t rip, uint64_t rsp, uint64_t opt, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "Divide by zero fault");
}

/// @brief Debug fault handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param opt Optional parameter generated by ASM layer (currently always zero)
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_debug_fault_handler(uint64_t rip, uint64_t rsp, uint64_t opt, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "Debug fault");
}

/// @brief Breakpoint trap handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param opt Optional parameter generated by ASM layer (currently always zero)
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_brkpt_trap_handler(uint64_t rip, uint64_t rsp, uint64_t opt, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "Breakpoint trap");
}

/// @brief Overflow trap handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param opt Optional parameter generated by ASM layer (currently always zero)
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_overflow_trap_handler(uint64_t rip, uint64_t rsp, uint64_t opt, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "Overflow");
}

/// @brief Bounds range fault handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param opt Optional parameter generated by ASM layer (currently always zero)
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_bound_range_fault_handler(uint64_t rip, uint64_t rsp, uint64_t opt, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "Bound range fault");
}

/// @brief Invalid opcode fault handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param opt Optional parameter generated by ASM layer (currently always zero)
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_invalid_opcode_fault_handler(uint64_t rip, uint64_t rsp, uint64_t opt, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "Invalid opcode");
}

/// @brief Device not available fault handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param opt Optional parameter generated by ASM layer (currently always zero)
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_device_not_avail_fault_handler(uint64_t rip, uint64_t rsp, uint64_t opt, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "Device not available");
}

/// @brief Double fault handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param err_code The error code generated by the CPU
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_double_fault_abort_handler(uint64_t rip, uint64_t rsp, uint64_t err_code, uint64_t k_rsp)
{
  // Don't try anything fancy with a double fault - it usually suggests something wrong in the kernel anyway.
  panic("Double-fault");
}

/// @brief Invalid TSS fault handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param err_code The error code generated by the CPU
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_invalid_tss_fault_handler(uint64_t rip, uint64_t rsp, uint64_t err_code, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "Invalid TSS");
}

/// @brief Segment not present fault handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param err_code The error code generated by the CPU
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_seg_not_present_fault_handler(uint64_t rip, uint64_t rsp, uint64_t err_code, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "Segment not present");
}

/// @brief Stack selector fault handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param err_code The error code generated by the CPU
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_ss_fault_handler(uint64_t rip, uint64_t rsp, uint64_t err_code, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "Stack selector fault");
}

/// @brief General protection fault handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param err_code The error code generated by the CPU
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment, while displaying the barest of diagnostics
void proc_gen_prot_fault_handler(uint64_t rip, uint64_t rsp, uint64_t err_code, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "General protection fault");
}

/// @brief Floating point exception fault handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param opt Optional parameter generated by ASM layer (currently always zero)
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_fp_except_fault_handler(uint64_t rip, uint64_t rsp, uint64_t opt, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "Floating point exception fault");
}

/// @brief Alignment check fault handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param err_code The error code generated by the CPU
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_align_check_fault_handler(uint64_t rip, uint64_t rsp, uint64_t err_code, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "Alignment check fault");
}

/// @brief Machine check abort handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param opt Optional parameter generated by ASM layer (currently always zero)
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_machine_check_abort_handler(uint64_t rip, uint64_t rsp, uint64_t opt, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "Machine check failed");
}

/// @brief SIMD floating point exception handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param opt Optional parameter generated by ASM layer (currently always zero)
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_simd_fpe_fault_handler(uint64_t rip, uint64_t rsp, uint64_t opt, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "SIMD floating point fault");
}

/// @brief Virtualization exception fault handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param opt Optional parameter generated by ASM layer (currently always zero)
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_virt_except_fault_handler(uint64_t rip, uint64_t rsp, uint64_t opt, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "Virtualization exception");
}

/// @brief Security fault handler
///
/// @param rip Address of the instruction that generated this interrupt
///
/// @param rsp Address of the stack when this interrupt was generated
///
/// @param err_code The error code generated by the CPU
///
/// @param k_rsp Stack saved by the kernel containing calling process context.
///
/// Simply crashes at the moment
void proc_security_fault_handler(uint64_t rip, uint64_t rsp, uint64_t err_code, uint64_t k_rsp)
{
  default_handler(k_rsp, rip, rsp, "Security fault");
}

/// @brief Handles page faults
///
/// Proper docs to follow when the system makes actual use of page faults.
///
/// @param fault_code See the Intel manual for more
/// @param fault_addr See the Intel manual for more
/// @param fault_instruction See the Intel manual for more
/// @param rsp Address of the stack in the thread where this interrupt was generated
/// @param k_rsp Address of the stack of the interrupt handler
void proc_page_fault_handler(uint64_t fault_code,
                             uint64_t fault_addr,
                             uint64_t fault_instruction,
                             uint64_t rsp,
                             uint64_t k_rsp)
{
  KL_TRC_ENTRY;
  static bool in_page_fault = false;

  if (!in_page_fault)
  {
    in_page_fault = true;
    KL_TRC_TRACE(TRC_LVL::EXTRA, "fault code: ", fault_code, "\n");
    KL_TRC_TRACE(TRC_LVL::EXTRA, "CR2 (bad mem address): ", fault_addr, "\n");
    KL_TRC_TRACE(TRC_LVL::EXTRA, "Instruction pointer: ", fault_instruction, "\n");
    if ((fault_code & 0x10) == 0)
    {
      // The fault wasn't caused by an instruction fetch, ergo we should be able to read & print the instruction...
      KL_TRC_TRACE(TRC_LVL::EXTRA,
                  "Instruction bytes x8: ", *(reinterpret_cast<uint64_t *>(fault_instruction)), "\n");
    }
    in_page_fault = false;
  }
  KL_TRC_EXIT;
  panic("Page fault!", true, k_rsp, fault_instruction, rsp);
}
